

























                               C I T A D E L - 8 6

                                      V3.49

                              Implementation Notes

                                   by Hue, Jr.

                             C-86 Test System Sysop

                                 (612) 470-9635

                                     97Jan13




























                                Table of Contents

     I. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . 1
       I.1 Code Structure. . . . . . . . . . . . . . . . . . . . . . . . 1
         I.1.a 1986. . . . . . . . . . . . . . . . . . . . . . . . . . . 1
         I.1.b 1990. . . . . . . . . . . . . . . . . . . . . . . . . . . 2
     II. Constants and Data. . . . . . . . . . . . . . . . . . . . . . . 2
       II.1 ANSI Notes (1989?) . . . . . . . . . . . . . . . . . . . . . 3
       II.2 Other Code Notes . . . . . . . . . . . . . . . . . . . . . . 3
         II.2.a Unprovided Code. . . . . . . . . . . . . . . . . . . . . 3
       II.3 Specifics. . . . . . . . . . . . . . . . . . . . . . . . . . 4
         II.3.a Typedefs . . . . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.i MSG_NUMBER . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.ii SECTOR_ID . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.iii AN_UNSIGNED. . . . . . . . . . . . . . . . . . . . 4
           II.3.a.iv DATA_BLOCK. . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.v CRC_TYPE . . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.vi SYS_FILE. . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.vii NET_AREA . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.viii SYS_AREA. . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.ix MULTI_NET_DATA. . . . . . . . . . . . . . . . . . . 4
           II.3.a.x UNS_32 . . . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.xi UNS_16. . . . . . . . . . . . . . . . . . . . . . . 4
           II.3.a.xii NET_AREA . . . . . . . . . . . . . . . . . . . . . 5
           II.3.a.xiii SYS_AREA. . . . . . . . . . . . . . . . . . . . . 5
           II.3.a.xiv DependentData. . . . . . . . . . . . . . . . . . . 5
           II.3.a.xv MenuId. . . . . . . . . . . . . . . . . . . . . . . 5
           II.3.a.xvi SystemProtocols. . . . . . . . . . . . . . . . . . 5
         II.3.b Global Data. . . . . . . . . . . . . . . . . . . . . . . 5
           II.3.b.i Fopen() modes. . . . . . . . . . . . . . . . . . . . 5
           II.3.b.ii Miscellaneous Garbage . . . . . . . . . . . . . . . 6
         II.3.c Constants. . . . . . . . . . . . . . . . . . . . . . . . 6
           II.3.c.i #define COMMENT_HEADER . . . . . . . . . . . . . . . 6
           II.3.c.ii #define WXMODEM_AVAILABLE . . . . . . . . . . . . . 6
           II.3.c.iii #define MAX_FILENAME . . . . . . . . . . . . . . . 6
           II.3.c.iv #define MSG_SECT_SIZE . . . . . . . . . . . . . . . 6
           II.3.c.v #define SIZE_SYS_FILE. . . . . . . . . . . . . . . . 7
           II.3.c.vi #define BOOLEAN_FLAG(x) . . . . . . . . . . . . . . 7
           II.3.c.vii #define LOCKFILE . . . . . . . . . . . . . . . . . 7
           II.3.c.viii #define S_MSG_MASK. . . . . . . . . . . . . . . . 7
           II.3.c.ix #define NO_STAT . . . . . . . . . . . . . . . . . . 7
           II.3.c.x #define NO_MENU. . . . . . . . . . . . . . . . . . . 7
     III. Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . 7
       III.1 Modem stuff . . . . . . . . . . . . . . . . . . . . . . . . 8
       III.2 Weird Disk Shit . . . . . . . . . . . . . . . . . . . . . . 11
       III.3 Console Stuff . . . . . . . . . . . . . . . . . . . . . . . 11
         III.3.a Sysop Interactions. . . . . . . . . . . . . . . . . . . 13
       III.4 Area Stuff. . . . . . . . . . . . . . . . . . . . . . . . . 18
       III.5 File Stuff. . . . . . . . . . . . . . . . . . . . . . . . . 20
       III.6 System Formatting Functions . . . . . . . . . . . . . . . . 21
       III.7 Timers. . . . . . . . . . . . . . . . . . . . . . . . . . . 22
       III.8 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . 24
       III.9 Virtual Room Interface. . . . . . . . . . . . . . . . . . . 28
       III.10 File Comments. . . . . . . . . . . . . . . . . . . . . . . 29
       III.11 Compressed Files . . . . . . . . . . . . . . . . . . . . . 30
       III.12 External Protocols . . . . . . . . . . . . . . . . . . . . 32
       III.13 Doors. . . . . . . . . . . . . . . . . . . . . . . . . . . 32
       III.14 External Message Editors . . . . . . . . . . . . . . . . . 34





                                     - i -




       III.15 Network Cache Support. . . . . . . . . . . . . . . . . . . 34
       III.16 Biography support. . . . . . . . . . . . . . . . . . . . . 35
     IV. SysCfg.C. . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
     V. SysUtil.C. . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
     VI. CREDITS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
     Appendix A. Index . . . . . . . . . . . . . . . . . . . . . . . . . 38























































                                     - ii -






     I. Introduction
        This file contains some informal notes on this implementation of
     Citadel.  Citadel-86 is designed to run on Zenith Z-100s, IBM PCs
     and clones using MS-DOS 2.x or 3.x.  It has an adequate network
     ability, and other enhancements that were not present in the code
     from which this implementation derives.  (That code was CP/M Citadel
     2.10, acquired from the CUG by Ray Schneider.)

     I.1 Code Structure

     I.1.a 1986
        At the present time, a need has been identified to re-arrange the
     source code.  The driving force behind this need is the fact that
     the source for Citadel-86 is being used to derive two new
     implementations of Citadel, one for the Amiga and one for the Atari
     ST.  This fact, in itself, does not warrant a change in the source
     used for the Citadel-86 implementation.  However, both porters of
     the code have indicated to me an interest in doing further ports of
     the code as new enhancements are made to the Citadel-86
     implementation.  Since repeated ports of the code could result in
     insanity for these people, the source code is being re-arranged to
     ease the successive ports as much as possible.

        The basic idea, of course, in making the ports easier is to make
     the source code as portable as possible between compilers.  There
     are two salient points: first, that there will be parts of the code
     that take advantage of eccentricities inherent in the compiler used
     for Citadel-86; second, that there will be code that depends on
     either the machines, the Operating System, or the compiler in
     question (but are not dependent on the eccentricities).

        The solution to the first point is to simply check the code as
     much as possible and change it to avoid all confirmed eccentricities.
     As any experienced programmer knows, this is always an ongoing,
     neverending task; all porters should be aware that despite all
     attempts to make the code designated as 'portable' actually portable,
     some of it may not be.  This will be a certainty if your compiler
     deviates significantly from K & R.  Fortunately, as the years pass K&
     R/ANSI consistency is becoming a greater and greater marketing point,
     and therefore compilers are becoming more and more compatible.

        The solution to the second point is to find and separate all such
     code out from the main source into a set of files that will be
     designated as 'non-portable.' The responsibility of any porter, then,
     would be to fill in the blanks; the functions, data, etc.  that is
     needed by the portable parts of Citadel to run would be the
     responsibility of the porter.  Since the plan is not to change the
     system dependencies, only to add to them, successive ports shouldn't
     be nightmarish, only somewhat time-consuming.

        Therefore, the real purpose of this file is to give the potential
     porter a place to start with the port.  This is not the end-all of
     the port, of course.







                                     - 1 -




        NOTE: In the past years, I've been through a lot of dreams and
     watched them crash.  This file is a well-meaning attempt, but don't
     be surprised to find stuff in the source that I didn't note here.
     That's the way I'm built.

     I.1.b 1990
        ADDENDUM: The results of the above ports were mixed.  The person
     who ported Citadel-86 to the Atari ST (STadel) and I parted ways
     rather violently and bitterly.  The port to the Amiga, after a
     period of dormancy, has been repeated and will continue to be
     repeated.  So the Amiga port was, more or less, a success.

        (1992) The Amiga port is now being continued by Tony Preston
     after Jay Johnson ran out of time to keep working on it.

     II. Constants and Data
        What follows is a list of the functions, constants, and data the
     porter must provide that have been designated as "system dependent"
     by me.  You may not agree with me, but a lot of programming is a
     matter of opinion.  How you implement them is entirely up to you;
     you can do them as C functions, as #defines, as parameterized
     #defines, or using any other trick that you have up your sleeve;
     after all, it's YOUR port.  If you look at my implementation, you'll
     find I mixed functions with parameterized #defines.  My source also
     has some info on the abstract concepts used for a lot of this stuff,
     probably better explained in there than here; refer to both.

        The C-86 implementation System Dependent code is divided into
     several files; this is being explained only out of academic interest,
     although some ports may find it useful to steal code from these
     files, particularly for result code handling and the like.  Feel
     free to use that code for the port, but please don't use it in other
     projects.

        SysDep.H - contains all code that belongs in a header file but is
     system dependent (e.g., typedef definitions for SYS_AREA).  This
     file must exist in any port, since Ctdl.H, which is included by all
     Citadel source files, includes it.

        SysDep1.C, Sysdep2.C - These two files contain the majority of
     the system dependent code of Citadel-86, including baud handling,
     keyboard handling, areas handling, timers, etc.

        SysCfg.C - Contains system dependent code necessary for the
     correct functioning of Citadel's CONFG program.

        SysUtil.C - Contains necessary system dependent code for the
     Citadel Utilities.

        SysArc.C - Contains code implementing the file archiving
     functions (ARC, ZIP, etc).

        CitVid.C - This implements Citadel-86 screen handling (direct
     screen writing).







                                     - 2 -




        SysZen.C - This file contains Zenith-100 specific modem and
     screen functions.

        SysIbm.C - This file contains PClone specific functions.

        SysZm.C - This file implements External Protocols for Citadel-86.

        SysDoor.C - This file implements doors in Citadel-86.

        SysEdit.C - This file implements external editors in Citadel-86.

        CitZen.obj - Binaries for modem interaction; source has been lost.

        TISOURCE.ZIP - Robert Nelson's contribution for TI PC Citadel.
     No longer supported.

     II.1 ANSI Notes (1989?)
        Citadel was written well before ANSI started trying to
     standardize C, and the dialect it was written in was fairly bizarre
     (BDS C, by Leor Zolman).  During the porting process from CP/M to
     MSDOS, it came fairly close to K&R C, and the maintenance process
     has cleaned most, perhaps all, of the remaining inconsistencies.
     However, until now no attempt has been made to "ANSI-tize" the code,
     due to the fact that many compilers do not yet support the ANSI
     "standard" (which has only just been ratified or passed or whatever
     it is that ANSI does).

        While most of the features of ANSI C are either questionable or
     only kind of nice, one is very* nice -- prototyping.  Therefore,
     Citadel-86 now uses prototyping.  If your compiler supports
     prototyping, then you should define the constant ANSI_PROTOTYPING in
     your SYSDEP.H.

        You can wait on this until you have working code, if you are not
     familiar with prototyping.

        If you do not have an ANSI compatible compiler, or the compiler
     does not support the data type 'void', then I suggest that you place

        typedef int void;

     in your SysDep.H, and enjoy tracing oddities of C.

     II.2 Other Code Notes

     II.2.a Unprovided Code
        Not all the code for Citadel-86 is included in the source
     provided.  This is due to the fact that some of the code I use in
     Citadel-86 was originally written for commercial purposes, and while
     I have permission to use it in Citadel-86, I cannot distribute it.
     These omissions are confined to the system dependent code (so far),
     so this should not be a real problem.









                                     - 3 -




     II.3 Specifics

     II.3.a Typedefs
        Citadel requires a number of variables who's implementation will
     vary from system to system.  For instance, an int on one machine may
     be 32 bits, which is enough for a message number, while on another
     an int will only be 16 bits, which is not big enough, forcing the
     programmer to go to a long or unsigned long.  Directories are
     another area.  The following typedefs MUST be present in SYSDEP.H.

     II.3.a.i MSG_NUMBER
        The implementation of a message number.  31 bits is recommended.
     Please leave one bit available as a flag for a current kludge.

     II.3.a.ii SECTOR_ID
        ID of a 'sector' of the message file.  A sector in Citadel terms
     is 128 bytes; therefore, the implementation of a SECTOR_ID
     determines the maximum size of the message file.  For instance, 16
     bits will get you about a 8 meg message file max (I think).

     II.3.a.iii AN_UNSIGNED
        Preferably, an 8-bit unsigned quality.  Used for modem input,
     miscellaneous.

     II.3.a.iv DATA_BLOCK
        Should be defined as an array of 128 bytes, preferably unsigned.
     Used for handling the message file (which is encrypted, hence the
     unsigned request) and XMODEM input.

     II.3.a.v CRC_TYPE
        For calculating XMODEM-CRC values.  Again, probably should be
     unsigned.

     II.3.a.vi SYS_FILE
        This should define a string that can handle all system names.

     II.3.a.vii NET_AREA
        Defines what an area that will be used by the net can look like.

     II.3.a.viii SYS_AREA
        Defines what an area that can be occupied by one of the Citadel
     system files (CTDLMSG.SYS, etc.) can look like.

     II.3.a.ix MULTI_NET_DATA
        Defines how the multi-net option data structures are defined.
     Preferably this should be an unsigned long int.

     II.3.a.x UNS_32
        This should be typedefed so that variables of this type function
     as 32 bit unsigned integers.  This is used primarily for reading SEA
     ARC files.

     II.3.a.xi UNS_16
        This should be typedefed so that variables of this type function
     as 16 bit unsigned integers.  This is used primarily for reading SEA
     ARC files.





                                     - 4 -




     II.3.a.xii NET_AREA
        This typedefed structure should contain the information necessary
     to move to an area in the system relevant to network work, such as
     sending files, etc.

     II.3.a.xiii SYS_AREA
        This typedef contains the information about a normal "area" of
     your system within which files are stored and accessed.  Citadel-86
     has implemented this as a pointer into a common data area, where the
     directory thus specified can only be a subdirectory of the current
     directory.

     II.3.a.xiv DependentData
        This typedef contains all system dependent data to be saved in
     CtdlTabl.Sys.  See the CONFIG structure in CTDL.H to see where
     DependentData is located.  All data in this structure (as in all the
     structures in this document) are accessed only via SysDep
     functionality.

     II.3.a.xv MenuId
        This identifies a system console screen menu.

     II.3.a.xvi SystemProtocols
        This typedef contains the information necessary to run some
     external protocol.  See the section on External Protocols.

     II.3.b Global Data
        These variables must* be declared in one of your SysDep files
     such that they are available to the rest of the world as externs.
     They must be initialized in accordance to the description provided
     here (or, alternatively, so that the source works right).  Normal
     initialization would be where they are declared, but some compilers
     don't support initializers, in which case some other method must be
     found.  Probably should consider the systemInit() function if you
     don't have initializers.

     II.3.b.i Fopen() modes.
        This section details different fopen() modes.  Due to differences
     in how text files are handled from OS to OS, many compilers have
     extended the fopen() modes that are available.  The modes listed
     below should cover most situations.

     char *R_W_ANY -- this indicates that the file should be opened in a
     mode that will allow reading and writing the file with no
     conversions to the data.  The file should be opened only if it
     exists; fopen() should return NULL if the file doesn't exist.

     char *READ_ANY -- this indicates that the file should be opened such
     that no data will go through a conversion.  If the file doesn't
     exist, fopen() should return NULL.

     char *READ_TEXT -- the file will be handled as strictly text; if
     necessary, conversions should be performed so that the text can be
     handled as a UNIX text file (most compilers provide an fopen() mode
     that will do this, hence the existence of this variable).






                                     - 5 -




     char *APPEND_TEXT -- this file should be opened so that text will
     only be appended to the end of the file, and it will be a normal
     text file; therefore, if conversions are necessary, they should be
     done.

     char *APPEND_ANY -- same as APPEND_TEXT, except that no* conversions
     should be performed on the outgoing data.

     char *A_C_TEXT -- Perhaps same as APPEND_ANY.  Needs investigation.

     char *WRITE_TEXT -- Delete the file of same name, and open the file
     for writing normal text -- the file will be a normal text file,
     implying conversions may be necessary.

     char *W_R_ANY -- Delete the file of same name, and open the file for
     writing and reading any data -- i.e., no conversions should be
     performed.

     char *WRITE_ANY -- same as W_R_ANY, except that the file is opened
     for write only.  There is really no meaningful difference between
     the two modes insofar as Citadel is concerned.

     II.3.b.ii Miscellaneous Garbage

     long DoorsUsed = 0l;

     This variable keeps record of how much time the current user has
     spent in doors.

     II.3.c Constants
        This section covers constants that may be system dependent, but
     used throughout Citadel.

     II.3.c.i #define COMMENT_HEADER
        If COMMENT_HEADER is defined then the string you define this to
     be is used as a filename to search for in the current directory
     during .Read Extended commands.  If found, the contents are printed
     before the actual files and descriptions are listed.

        If this is not defined, then the code that does this is disabled.

        See wild2Card() in areas.c for usage.

     II.3.c.ii #define WXMODEM_AVAILABLE
        Define this constant only if you want Wxmodem available as an
     internal protocol.

     II.3.c.iii #define MAX_FILENAME
        This should be the max length of a filename in this OS, including
     the EOS byte.  Used in #events and directory display.

     II.3.c.iv #define MSG_SECT_SIZE
        This defines the size of a message 'psuedo-sector'.  The message
     file is modeled after the old CP/M Citadel message file, which
     consists of a series of encrypted CP/M sectors.  In order to
     maintain encryption, the message file is still maintained in that





                                     - 6 -




     way, despite the fact that now normal C I/O functions such as fread()
     and fwrite() are used.  However, some systems may function better
     with a sector size different than the original 128 bytes, because
     the message file is only accessed one sector at a time.  NOTE:
     Please make sure that the number you specify is a multiple of 128,
     or file size displayed on .RS will NOT be displayed correctly!

     II.3.c.v #define SIZE_SYS_FILE
        This specifies the largest size the name of a system file can be,
     and will be used with most implementations in the typedef for
     SYS_FILE.  Don't forget to add 1 for the ending NULL!

     II.3.c.vi #define BOOLEAN_FLAG(x)
        This specifies the representation for data types that will assume
     BOOLEAN values.  Since this type is guaranteed* only to be used in
     structures, it may be defined as a bit flag (as in the C-86
     implementation).  If you do not have bit flags, then you can do it
     as a char easily.

     II.3.c.vii #define LOCKFILE
        This should be the name of a "lockfile".  When Citadel is coming
     up it tests for the existence of such a file.  If it exists, then
     Citadel assumes it is already up and the sysop is mistakenly trying
     to bring it up from within itself (this happens when the sysop has
     "shelled" out, usually via Outside Commands).

     II.3.c.viii #define S_MSG_MASK
        This is a bit mask which is applied to values of type MSG_NUMBER
     in order to set a flag to implement the Skip single message in Mail
     feature.  This is a KLUDGE (Yes! I admit it!) and may go away
     someday, but for the moment it exists.  Citadel-86 happens to
     reserve the high bit for this flag.

     II.3.c.ix #define NO_STAT
        If you don't have the stat() function available (see Aff.c in
     Utilities) then set this definition and then peruse Aff.c before
     attempting to port it.

     II.3.c.x #define NO_MENU
        This is a constant of type MenuId which should indicate to your
     implementation of system console Sysop Menus that this particular
     interaction is not attached to any particular menu.  Most screen
     interactions are, and the MenuId of the associated menu is therefore
     passed to the system dependent routines so they may do something
     with it.  For instance, I use it in Citadel-86 to find out what the
     current menu colors are and so make a pretty prompt out of it.  But
     when the portable code doesn't actually know what menu is currently
     up (lazy programming in the portable code, actually), it passes this
     constant to the interaction routine.

     III. Functions
        These are the functions the porter must provide.









                                     - 7 -




     III.1 Modem stuff

     void ModemOpen(char DoorReturn)

        This function is called precisely once, in initCitadel(), to open
     the modem.  It constitutes the first access to the modem.
     DoorReturn indicates the system is coming up either as a door or
     coming back from a door (for those installations which implement
     doors by having Citadel come down before execution), and thus the
     ModemOpen call should be careful not to disturb the modem port or
     send an init string out the port when DoorReturn is TRUE.

     -------

     void ModemShutdown(char KillCarr)

        This function is called precisely once, on exit from Citadel
     (either from the main() function or from crashout()).  It is charged
     with shutting down modem I/O as Citadel is brought down.  If
     KillCarr is FALSE, then this indicates the modem should NOT be
     disabled (i.e., carrier should not be dropped), usually because a
     door is to be brought up.

     -------

     void HangUp(char FromNet)

        This function hangs the modem up and then re-enables it.  The
     parameter lets you do a final pause, if necessary, on user log outs
     (otherwise, if you do lock port, LONOTICE can be partially lost).
     This is the place to reinitialize the modem at highest baud rate if
     you need to do so.

     -------

     void Reinitialize(void)

        This function just reinits the modem.  It's called only from
     Citadel's <R>einit option from the sysop menu.

     -------

     AN_UNSIGNED inp(void)

        This function returns a character "from the modem." In other
     words, however you got the data, we want the next byte of it.

     -------

     int MIReady(void)

        This function returns TRUE if there is a character from the modem
     port awaiting processing.

     -------






                                     - 8 -




     char outMod(int c)

        outMod() stuffs the character in c out the modem.  Returns FALSE
     if problems.

     -------

     char fastMod(int c)

        This function stuffs a character out the modem port but doesn't
     wait around to make sure it made it.  Returns FALSE if problems.

     -------

     int gotCarrier(void)

        This function returns 0 if there is no carrier at the modem port,
     a non-zero if there is carrier.

     -------

     int changeBauds(MenuId id)

        This function queries the system operator for the new baud rate
     to set the modem to, and then does so.  The id will be the menu id
     obtained from a RegisterSysopMenu() call (see way below).

     -------

     void DisableModem(char FromNet)

        This function's responsibility is to ensure that the modem will
     not accept incoming calls (that is, answer the phone).  This is not
     necessarily a hang up function; it exists to allow the sysop to use
     his or her system without having to manually play games with his
     modem or phone system.  FromNet indicates whether or not the call
     has to do with the network.  If not, you may wish to let the user
     have a choice between your 'normal' disablement procedure and
     something else (like forcing the modem offhook).

     -------

     void EnableModem(char FromNet)

        This function's responsibility is to ensure that the modem is
     enabled, which is defined as the modem is able to generate carrier
     for auto-answer.  You should not assume that the modem was
     previously disabled, unless you're very familiar with the code and
     what it purports to do.  FromNet indicates whether or not the call
     involves the network.

     -------

     int FindBaud()







                                     - 9 -




        This function must find, in some way, the baud rate of the caller.
     If it is unsuccessful, it should return -1 and dump carrier (the
     caller uses gotCarrier() to determine if baud detection was adequate
     on return from FindBaud()).  If it is successful, it should return
     the Baud detected (300, 1200, etc etc).

        -1 can also be returned without dumping carrier to indicate that
     while the real baud rate is unknown, the call can still be
     successful due to port locking in the system dependencies.

     -------

     char getNetBaud(void)

        This function must find the baud rate of the potential network
     caller.  This is more complex than it might sound, because the
     method of baud rate detection must take into account the fact that
     'call stabilization' must also occur, along with all the timing
     thingies.  The implementation for Citadel-86 contains a fairly
     generic attempt that includes stuff for both systems that can detect
     directly (PClones with internal Hayes, mostly), and systems that
     must detect baud rate from the data incoming (much like the
     Find_baud() routine that is also present in SysDep.C).  Note the use
     of the "check_for_init()" function -- this function is present in
     NetMisc.C, and attempts to detect a call stabilization attempt.  Use
     it if possible -- it seems to work well.

        This function could well be the trickiest in SysDep.C.

        If this function fails, it should return FALSE and dump carrier;
     otherwise, it should return TRUE.

     -------

     int setNetCallBaud(int targetBaudCode)

        targetBaudCode is the baud code, as defined in the CTDL.H header,
     for a system about to be called for networking.  The purpose of this
     function is to set the system's modem for calling at the fastest
     baud rate that is used by both this system and the target system.

     -------

     void ReInitModem(void)

        This function is called to reinitialize the modem at the highest
     supported baud rate.

     -------

     void BufferingOn(void)

        Turn on a buffering mechanism for increasing performance
     throughput.  If you have nothing like this you may wish to just make
     these into meaningless #defines.  Used in Msg.C and Modem.C.






                                     - 10 -




     -------

     void BufferingOff(void)

        Paired with the above.  Please examine usage closely before
     implementing; must be able to handle both carrier loss and non-call
     to BufferingOn() correctly.  Used in Msg.C and Modem.C.

     -------

     int RottenDial(char )*

        This function is in place to handle very strange computers which
     need odd dialing instructions.  The string passed to the function is
     the same as would be passed directly to the modem.  The value
     returned by this function should be as follows:

        1 (TRUE): indicates the dialout took place and Citadel-86 can now
     start scanning for carrier.

        0 (FALSE): indicates no dialout took place; in other words,
     Citadel-86 should simply try to dial the modem normally.  This
     implies

        #define RottenDial(x) (0)

     would be a good implementation if you have a normal serial port.

        -1 (ERROR): indicates the dialout took place and the dialout
     routine detected a busy signal.

     -------

     III.2 Weird Disk Shit

     int mvToHomeDisk(int x)

        This function is a holdover from both the CP/M and MSDOS days.
     Someday, it may no longer be used; a better abstraction is needed.
     It makes the given disk, which is an int (0=A, 1=B, etc.), the
     default disk.  It may be in use only in the Confg program.  Probably
     most ports can just make a null #define out of this.

     -------

     III.3 Console Stuff

     char getCh(void)

        This function fetches a character from the console and returns it.

     -------

     char KBReady(void)







                                     - 11 -




        KBReady() returns TRUE if there is a character waiting at the
     sysConsole Keyboard, else FALSE.

     -------

     void mputChar(char c)

        This function writes a char to the sysConsole.  This function is
     not used by all output functions; for instance, printf() doesn't use
     it (of course).  However, there are not many printf()s used in the
     system, and most other sysConsole output should* go through this
     function.  This function has the additional responsibility of
     obeying the global variable echoChar, which specifies whether any
     output should be sent to the sysConsole.  It can also be used to
     screen out bells, etc., that may be undesirable.

     -------

     int simpleGetch(void)

        This function simply waits at the keyboard until something is
     typed, then returns it.

     -------

     void ScreenUser(void)

        This function is called each time a room prompt is written to the
     user and console.  Traditionally, Citadel writes the user's name in
     parenthesis above the room name, like this:

        (Joe User)
        Hallowed Chamber>

     However, you may want a different, or no, output, since Citadel now
     has hooks for a statusline (implemented by the porter, of course).

     -------

     void ScrNewUser(void)

        This function is called when changes occur that might impact a
     statusline.  This function is called from a number of different
     places.

     -------

     void SpecialMessage(char *message)

        This function is called when a special message should be printed
     on the status line.

     -------

     void ScrTimeUpdate(int hour, int minutes)






                                     - 12 -




        This function is used to implement an optional statusline clock
     in Citadel.  If you, the porter, decide to have a system clock, then
     you must have the line

        #define SYSTEM_CLOCK

     present in your SYSDEP.H file, and you must implement this function.
     Minutes will be in the range 0 - 59 inclusive, hours will be in the
     range 0 - 23 inclusive.  Typically, this function is called once a
     minute; however, this is not consistent.  Prolonged uninterrupted
     reads and downloads will cause delays in this function, and thus the
     Citadel system clock is not particularly accurate.

        If your target computer already has a system clock available (say,
     on a multitasking system) you may not wish to bother with this.  But
     it's nice on MiseryDos computers.

     -------

     III.3.a Sysop Interactions
        Citadel-86's portable code expects a certain set of special sysop
     interaction routines to be available for use when Citadel-86 is in
     its sysop menus.  These routines can either be implemented as simple
     calls to normal Citadel routines for display and information
     acquisition, or they can be used as a way to set up some sort of
     pop-up windows system.  If the latter course is used, then the
     extern char "onConsole" should be checked before displaying such
     windows; if this variable is TRUE then the current user is at the
     System Console, and if not TRUE, then the user is remote.

        In order to make possible the layering of menus (although the
     portable code currently deactivates each menu before calling another),
     each menu the portable code creates has a variable of type MenuId, a
     system-dependent definition, associated with it.  This variable is
     set by a call to the function RegisterSysopMenu() (first function
     described herein), which returns this id.  All calls to other sysop
     interaction routines will pass in a variable of type MenuId, which
     will be the menu with which this interaction will be associated with.
     The implementation, if it is doing anything at all special, can use
     this MenuId to discover what menu this action is associated with.

        If the implementor does not wish to do anything special, each
     routine below will include a suggested default implementation.

        REMEMBER: if you do implement these in some special way, it is
     YOUR responsibility to remember sometimes the sysop may be remote
     from you! Just about everyone of these routines should then have an
     "if (onConsole)...  else ..." statement to make sure the alternate
     interface is still available.  Generally speaking, the default
     suggested implementations listed below will function extremely well
     as the code in the "else..." part of the "if statement" cited above.

     -------








                                     - 13 -




     MenuId RegisterSysopMenu(char *MenuName, char *Opts[], char *
     MenuTitle)

        This function is designated to initialize and display an initial
     menu.  The first parameter is the filename of the textfile menu
     associated with these options, the second is an array of actual Menu
     options (ends with a NULL pointer), and the third is the title of
     the menu.

        The second argument is the most important of the three.  The
     first character of each element of the array should be taken to be
     the selector for that element of the array.  When input is asked for
     pertaining to this menu, this array (or derivative thereof) should
     be scanned for the input character by comparing it against the first
     character (the selector) of each element.  Also, for display
     purposes these strings may contain Backspace characters: the first
     character remains the selector, but the string isn't a word unless
     the backspace is used, so it's embedded in the string.  This is used
     mostly for the e<X>it options.

        The default implementation for this function should consist of
     the following function:

MenuId RegisterSysopMenu(char *MenuName, char *Opts[], char *MenuTitle)
{
	RegisterThisMenu(MenuName, Opts);
	return 0;	/* meaningless value, yes */
}

     -------

     int GetSysopMenuChar(MenuId id)

        This function is used to obtain input from the system operator.
     The value returned should already have been error-checked against
     possible return values as specified in the Opts[] array associated
     with the id variable passed in.  Error displays, if any, are your
     responsibility.  The only possible return not specified in Opts[] is
     -1, which indicates some sort of failure and is taken to be
     equivalent to whatever the menu exit option is.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define GetSysopMenuChar(id) GetMenuChar()

     -------

     void CloseSysopMenu(MenuId id)

        This function should close up all data structures associated with
     the id of the menu, and erase the menu from the screen.

        The default implementation for this function should consist of
     the following entry in sysdep.h:






                                     - 14 -




        #define CloseSysopMenu(id)

     -------

     void SysopMenuPrompt(MenuId id, char *prompt)

        This function is used to ask for input from the sysop in a
     generic manner.  In the old implementation, its equivalent would
     display "privileged fn:", etc., and that's what is passed to it here.
     This may be a virtual do-nothing when the sysop is onConsole (it is
     in my implementation).  But you may be doing something different
     than I, and in any case when the sysop is !onConsole ...

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopMenuPrompt(id, prompt) mPrintf(prompt)

     -------

     void SysopError(MenuId id, char *prompt)

        This function should display an error message to the sysop.  The
     id argument is the menu the error is associated with, which may or
     may not be useful.  (This may be NO_MENU.)

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopError(id, prompt) mPrintf(prompt)

     -------

     char SysopGetYesNo(MenuId id, char *info, char *prompt)

        This function retrieves a Yes/No response from the sysop and
     returns TRUE (Yes) or FALSE (No) to the calling function.  The id is
     the menu the question is associated with.  "info" is an informative
     text message about the question which should be printed along with
     the question (contained in prompt).

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopGetYesNo(id, info, prompt) getYesNo(prompt)

     -------

     void SysopRequestString(MenuId id, char *prompt, char *buf, int size,
     int flags)

        This function requests a string from the user.  The flags
     argument should be passed to getNormStr() if the sysop is remote.








                                     - 15 -




        The default implementation for this function should consist of
     the following entry in sysdep.h:

     #define SysopRequestString(id, prompt, buf, size, flags) \
     getNormStr(prompt, buf, size, flags)

     -------

     void SysopInfoReport(MenuId id, char *info)

        This function displays a short informative message, such as
     "enabled" or other message, to the sysop.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopInfoReport(id, info) mPrintf(info)

     -------

     void SysopDisplayInfo(MenuId id, char *info, char *title)

        This displays a BIG amount of information to the sysop, long
     enough that the sysop may not be able to grasp the full import of
     the message without several seconds of reading.  This might be a
     report on the status of a network node.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopDisplayInfo(id, info, title) mPrintf(info)

     -------

     long SysopGetNumber(MenuId id, char *prompt, long bottom, long top)

        This requests a number from the sysop within the given bounds.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopGetNumber(id, prompt, bottom, top) getNumber(prompt,
     bottom, top)

     -------

     MenuId SysopContinual(char *Title, char *prompt, int Width)

        This is another way to open a window on the screen for the sysop.
     The method of interaction is not through menus, but instead through
     string display and acquisition, etc.  This function, if especially
     implemented, should open up a window on the screen of at least width
     Width (depth is implementer's guess), using the given prompt.  The
     return value should be an identifier of type MenuId suitable for
     later reference when this window is being utilized.  As ever, the
     onConsole variable should be checked before creating windows.





                                     - 16 -




        The default implementation for this function should consist of
     the following function:

MenuId SysopContinual(char *prompt, int MaxWidth)
{
    mPrintf(prompt);
    return NO_MENU;
}

     -------

     void SysopContinualString(MenuId id, char *prompt, char *buf, int
     size)

        This function requests a string from the sysop from the specified
     window.  The string should have NormStr() run on it before this
     function terminates.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopContinualString(id, prompt, buf, size) \
        getNormStr(prompt, buf, size, 0)

     -------

     void SysopCloseContinual(MenuId id)

        This function closes a window opened through SysopContinual(),
     deallocating whatever is necessary.

        The default implementation for this function should consist of
     the following entry in sysdep.h:

        #define SysopCloseContinual(id)

     -------

     int SysopPrintf(MenuId id, char *format, ..).

        This function is printf() to the given window.  If the user is
     !onConsole, the resulting output should be stuffed through mFormat
     (like mPrintf()).

        The default implementation for this function should consist of
     formatting the output and then putting it through mPrintf.  Note
     that you can't use #define to get around writing a function unless
     you have a better preprocessor than I do.

     -------

     char NeedSysopInpPrompt(void)

        This function is basically a kludge to find out if after the
     display of a lot of data whether we need to prompt for something
     before we rewrite the menus.  Bleah.  See Netmisc.c.





                                     - 17 -




     -------

     III.4 Area Stuff

     void CitGetFileList(char *mask, SListBase *list, long before, long
     after, char *phrase)

        This function fills the list pointed at by *list with a list of
     files matching the mask specification + the date specifications +
     the phrase specification.  mask is usually input from the user;
     before and after are generated by analysis of a user input string
     converted to long ints via the sysdep function ReadDate().  This
     function is expected to convert each file's date to the long int
     format specified in ReadDate and then perform a check to make sure
     the file falls within the dates specified.  If phrase is anything
     but "", then CitGetFileList should scan the file's comment (if any)
     for phrase and, if not found, then not include the file in the list.
     Please examine the Citadel-86 implementation for more information
     and hints.

     -------

     void homeSpace(void)

        This function returns Citadel to its "home" area of the O.S.

     -------

     int netGetAreaV2(MenuId id, char *fn, struct fl_req *file_data, char
     ambiguous)

        This function obtains from the sysop the area within which
     Citadel is to store a file that has been obtained from the network.
     If this function fails (i.e., sysop aborts, etc.), return FALSE;
     otherwise, return TRUE.  The result should be placed in the area
     part of the file_data pointer.  The "ambiguous" variable indicates
     whether the file request is a request for all files matching a mask,
     or a single file.

     -------

     char netSetNewArea(NET_AREA *file_data)

        This function takes data indicating what area in the O.S.  should
     become the default area.  If problems, return 0; otherwise, 1.

     -------

     char *prtNetArea(NET_AREA *netArea)

        This function should form a string that gives a human readable
     designation of the net area passed to it, and returns a pointer to
     that string.  The string may be static if so desired.

     -------






                                     - 18 -




     char SetSpace(char *area)

        This function changes the default area from the home area to the
     area specified in the string.  If problems, return FALSE; otherwise,
     TRUE.

     -------

     char sysGetSendFilesV2(MenuId id, char *name, struct fl_send
     *sendWhat)

        This function should obtain from the sysop an indication (to be
     stored in the NET_AREA field and the filename variable, if necessary)
     of what file(s) are to be sent to another system on the network.
     The system has already been identified by the time this code is
     called.  Return 0 if there is an abort indication in this function,
     otherwise 1.

     -------

     long sysRoomLeft(void)

        This function should return the amount of room left in the Net
     Reception Area of the operating system for files incoming from the
     network.  Note that the byte count should be a long!

     -------

     void sysSendFiles(struct fl_send *sendWhat)

        This function should take the file(s) indicated by the *sendWhat
     variable and attempt to send them out on the net via calls to the
     netSendFile() function.  The system's current area should be the
     area designated as the Net Reception Area (set by the call in
     NETCALL.C); the strings sent to the netSendFile() function should be
     just filenames which the function can open via calls to safeopen().

     -------

     void RedirectName(char *target, char *directory, char *filename)

        This function is used to build a string which can open, rename,
     etc., a file.  "target" is the buffer to build the string into;
     "directory" is the directory string which was extracted from a
     #event of class "redirect" (i.e., it's the target directory which
     the file is to be placed in); "filename" is the actual name of the
     file.  RedirectName() must produce a valid string (in terms of the
     current platform), but needn't handle a situation such as when the
     directory doesn't actually exist.

     -------

     char ValidArea(char *area)








                                     - 19 -




        This function is called to check the passed in directory name for
     validity.  The data may be altered if necessary.  If a failure
     occurs then FALSE should be returned, otherwise TRUE should be
     returned.  The resultant string will probably be added to
     ctdldir.sys.

     -------

     III.5 File Stuff

     -------

     void makeSysName(SYS_FILE target, char *name, SYS_AREA *area)

        This function forms a filename that will allow access to the file
     specified by 'name', using the SYS_AREA pointed at by area.  The
     result should be placed in target.

     -------

     void SysArea(char *buf, SYS_AREA *area)

        This function forms a human-readable name for printing in some
     English capacity.  The result should be placed in target.

     -------

     void MakeDomainFileName(char *target, UNS_16 MapDir, UNS_16 FileName)

        This function is charged with creating a viable filename in the
     Domains directory which can then be opened, read from or written to,
     etc.  MapDir is the numeric directory, FileName is the actual
     filename (kept as a number).

     -------

     void MakeDomainDirectory(int dirnum)

        This function is charged with creating a directory in the Domains
     directory.  dirnum is the number of the directory to create.

     -------

     void KillDomainDirectory(int dirnum)

        This function is charged with killing a directory in the Domains
     directory.  dirnum is the number of the directory to kill.

     -------

     void MoveFile(char *oldname, char *newname)

        This function is responsible for renaming a file which may go
     across volume boundaries (from #NETAREA to #DOMAINAREA, for instance).
     C-86 is implementing by first checking to see if the files are on
     the same DOS volume, if so then call rename(), otherwise try to find
     some other way to do it.




                                     - 20 -




     -------

     char CopyFile(char *fname, aRoom *roomData)

        This function is responsible for copying the specified file into
     the disk area associated with the given room, returning TRUE if
     successful, FALSE otherwise.  It is also responsible for changing
     the contents of fname so any path specification is eliminated; only
     the filename should be placed in fname.

     -------

     int CopyFileGetComment(char *fname, int thisRoom, char *comment)

        This function is similar to CopyFile, above, except that rather
     than returning the size of the file it returns the file comment, if
     any, associated with the file as may have been found with the file
     just copied.  If none is found then the length of comment should be
     zero, thus signifying the lack of comment.  This function is used by
     the .AA command.

     -------

     void makeAuditName(char *logfn, char *str)

        This function produces a string in logfn, using str as a base
     ("CALLLOG.SYS", etc.), useable by safeopen to open as a file for
     writing.  This is used only for generating audit names, and is
     something of a kludge.

     -------

     FILE *safeopen(char *fn, char *mode)

        This function returns to the caller a FILE pointer associated
     with a file of the name fn.  mode is an indication of what mode to
     open the file in, such as READ_ANY, etc., which you should have
     defined as global thingies to indicate to you what mode to open the
     files in.  Return NULL if there is a failure in opening the file,
     such as non-existent.

     -------

     void totalBytes(long *size, FILE *fd)

        This function returns the size of the file specified by the FILE
     pointer *fd.

     -------

     III.6 System Formatting Functions
        Formatting of strings for destinations other than normal must
     somehow be accomplished.  Of course, this COULD be done with sprintf()
     calls followed by an appropriate call to another function.  However,
     this would also be hideously expensive, not to mention unaesthetic.
     Therefore, the following are required; the porter may deal with





                                     - 21 -




     these as s/he sees fit.  Recently it's become apparent ANSI has
     standardized this stuff...  thank ghod.

     -------

     void dPrintf(char *format, ..).

        This function must use putMsgChar() to write its resultant output
     to the message file.  Essentially, this function is used to write
     fields of a message to the message file(s).  At the end of this
     function there MUST be the call "putMsgChar(0);", or the message
     file will just be a mess!

     -------

     int mPrintf(char *format, ..).

        mPrintf() means "modem printf", which is what it is, somewhat.
     It does not, however, write directly to the modem; mPrintf() should
     be written to be a sPrintf() that calls mFormat() with the formatted
     string to finish the output.

     -------

     void splitF(FILE *diskFile, char *format, ..).

        This function formats its input to both the screen and, if the
     diskFile variable isn't NULL, to the file indicated by it.

     -------

     int NetPrintf(int *(method)(int c), char *format, ..).

        This function should format the message specified and stuff it
     into the given function.  It's final action should be

        (*method)(0);

     If any of the attempted uses of method return FALSE, then return
     FALSE immediately to the caller.  Otherwise, return TRUE.

     -------

     III.7 Timers
        See the SysDep2.c source for a good description of the model used
     for timers.

     -------

     long chkTimeSince(int TimerId)

        This function and its partners work together to perform a timing
     function for a portable timer, assuming that the host computer has
     adequate time facilities.  This function returns the number of
     seconds that have passed since the startTimer() function was last
     called for the given TimerId.  This function and startTimer() should
     support at least 10 timers; this may change in the future.




                                     - 22 -




     -------

     void pause(int i)

        pause() should cause the system to pause for i/100s of a second.

     -------

     void startTimer(int TimerId)

        startTimer() starts the "timer" identified by TimerId.  The only
     way in which a timer can be accessed is by checking it for how long
     has passed since this timer was started, via functions such as
     chkTimeSince().  This function and chkTimeSince() must support at
     least 10 timers; this may change in the future.

     -------

     void getRawDate(int *year, int *month, int *day, int *hours, int *
     minutes, int *seconds, int *milli)

        This function retrieves for Citadel the current time and date and
     places the values in the locations specified by the pointers passed
     in.  The year should be in 'normal' format, i.e.  1987; month should
     be a number between 1 and 12, inclusive; day should be between 1 and
     7, inclusive; hour should be in military notation; minutes should be
     between 0 and 59, inclusive; so should seconds; milli should be
     between 0 and 99, inclusive.

     -------

     void setRawDate(int year, int month, int day, int hour, int min)

        This function should allow access to changing the system date.
     Of course, if you can't, you can't....  NOTE: At this time
     Citadel-86 does NOT use this function, due to the mess it makes of
     events.

     -------

     int ReadDate(char *date, long *RetTime)

        This function's purpose is to interpret a string containing a
     "date spec", probably in a Citadel format, and return a long value
     (in the location pointed at by RetTime) that indicates its age.  The
     rule is that the return value should be consistent -- 88Jan08 should
     return a lower value than 88Jan09.  At the moment, a time-spec is
     not formally supported, but could be without change to the portable
     code.

        This function should return FALSE if the string is of length 0,
     ERROR if there was something wrong with the date spec, or TRUE if
     the date was successfully interpreted.








                                     - 23 -




        More of this code could be placed in the portable exception of
     Citadel-86, but it wasn't.  This gives the porter slightly more
     flexibility.  At the moment, a date spec looks like this: [yy]mmdd.
     year is optional, mm need only be long enough to be unique, dd can
     be single digit if necessary.

     -------

     long CurAbsolute(void)

        This function returns the current time in a format compatible
     with that used by the function ReadDate().  Used in a number of
     places.

     -------

     char *AbsToReadable(unsigned long lastdate)

        This function should be able to accept an unsigned long generated
     by a call to CurAbsolute() (another system dependent function) and
     make it into something readable by a human being, i.e., 90May11 @
     12:15pm, reflecting the meaning of the number.  The result should be
     returned in a static buffer.

     -------

     void MilliSecPause(int x)

        This function tells the system to pause/sleep for x milliseconds
     as accurately as possible (I use a Turbo C only call).  This is used
     in only one place, to implement the .ECD feature.

     -------

     III.8 Miscellaneous

     void copy_struct(char *src, char *dest)

        This function is a generic structure copier.  src and dest should
     be structures; the structures should be of the same type.
     copy_struct() should copy the contents of dest to src.  Normally,
     this should be implemented as a parameterized define that gets the
     addresses of src and dest and calls some sort of movmem() function.

     -------

     void copy_array(char *src, char *dest)

        This function is a generic array copier.  src and dest are arrays
     of the same number of elements and same type of elements.  This
     function will copy src to dest.

     -------

     void copy_ptr(char *src, char *dest, int s)






                                     - 24 -




        This is a generic pointer to array or array to pointer or pointer
     to pointer copy function, where s specifies the number of elements
     to copy.

     -------

     GiveSpaceLeft(int room)

        This is a rather vague function who's purpose is to give the
     amount of space left on some part of the system, associated with the
     given room.  Kind of "do with this what you will" situation.

     -------

     void systemCommands(void)

        This, too, is rather nebulous.  Essentially, allows access to the
     outside world for the Sysop or Remote Sysop.

     -------

     void systemInit(void)

        This function should take care of all system-dependent
     initializations that have nothing to do with the modem.  For
     instance, setting up windows, pipes, etc.

     -------

     void systemShutdown(void)

        This function should take care of all system-dependent shutdowns.

     -------

     int receive(int seconds)

        This is the classic Ward Christiansen 'receive' function, which
     is supposed to scan for a character for the specified number of
     seconds.  If there is a character during that wait, immediately
     return it.  If you timeout, return ERROR.

     -------

     char DialExternal(NetBuffer *netBuf)

        This function should try to perform a PCPursuit dial out given
     the information in the passed node record.  It should return TRUE if
     it thinks it has a good connection with the target, FALSE otherwise.

     -------

     char *GetPrefix(int code)








                                     - 25 -




        This function should return a pointer to a string appropriate for
     dialing out.  See the configuration function ReadDialOut().  This is
     a sad kludge to cover up one of my failings.

     -------

     int WhatDay(void)

        Returns what day it is, Sunday=0...

     -------

     void zero_struct(target)

        This function zeroes the specified structure.  target is a
     structure, not a pointer to a structure, so you should probably use
     a parameterized define on this one.

     -------

     void zero_array(char *target)

        This function zeroes the specified array.

     -------

     void ReadBps(char *str)

        This function is called to read the bps off of the command line.
     This is definitely a KLUDGE!

     -------

        Citadel supports uploading and downloading directly from Chat
     mode directly into and from the current room.  While two control
     keys are directly defined in Citadel for activating these functions,
     some computer systems may find it more convenient to assign these
     functions to special keys, such as the PGDN and PGUP keys of the IBM
     PC.  The following two functions exist to allow such abilities in a
     portable manner.

     -------

     char ChatSend(int s)

        This function is called to determine if the character s should
     activate the download function from Chat.

     -------

     char ChatEat(int s)

        This function is called to determine if the character s should
     activate the upload function from Chat.







                                     - 26 -




     -------

     void CallChat(int limit, int interruptable)

        This function is responsible for attempting to summon the sysop
     to a chat.  It need not check for the chat flags.  If the sysop
     answers, the main Citadel code will detect the answer by checking to
     see if there's any characters available at the console, so don't
     read any characters, only check for availability.

        limit is the number of times to call the sysop.  If interruptable
     is 0, then it's just a ring of the sysop, not an actually answerable
     thingie, and neither the sysop nor the user can interrupt.

     -------

     void BeNice(int where)

        This function allows multitasking systems to optimize their
     situations.  The where parameter indicates where BeNice() was called
     from.  INUSE_PAUSE means the system is in use but no input was
     received, so we are not very active at the moment.  IDLE_PAUSE means
     the system is not in use (system is not in CONSOLE mode and there is
     no carrier), so we can be really nice.  NET_PAUSE indicates the
     system is in network mode but not doing much at the moment (waiting
     for a call), so we can be sort of nice but not too generous.

     -------

     void ToTempArea(void)

        This function builds a temporary work area (directory, etc.) for
     Citadel and moves into it (if necessary).

     -------

     void KillTempArea(void)

        This function dismantles a temporary area built earlier by
     Citadel and does a homeSpace() call.

     -------

     char FileIntegrity(char *filename)

        Citadel can check the integrity of file uploads via a call to
     this function.  It should return TRUE if the file passes an
     integrity check or if such a check was bypassed.  Examples of such
     checks include ARC, ZIP, and ZOO files.  FALSE should be returned
     iff a test failed.

     -------

     char ValidDirFileName(char *fn)







                                     - 27 -




        This function is called to validate the name of a file.  This
     allows illegal file downloads (like "..\") to be refused.

     -------

     void NormalName(struct fl_send *file_to_send, char *buf)

        This function accepts the *file_to_send parameter and constructs
     from the pathname implied by the structure and places it in the
     buffer pointed at by buf.  Since part of the struct fl_send
     structure is system-dependent, this function exists.  The resulting
     name should be usable with access(), etc, unless of course it's an
     ambiguous name.

     -------

     int ResultVal(char *result)

        This function returns an int code indicating what the given
     result string from the modem was.  Please consult CTDL.H (look for
     R_BUSY) for the valid return codes.  This function is called by the
     network call out functions to determine call progress detection.

     -------

     III.9 Virtual Room Interface
        Citadel-86, as of V3.05, supports a Virtual Room ability in
     connection with the network.  Virtual Rooms are explained (well,
     sort of) in NETWORK3.MAN.  They are used to hold temporary files
     that contain the contents of a "virtual" room which doesn't exist on
     your system, but which you are backboning for other systems.  The
     virtual rooms use the structure of the native operating system to
     organize the incoming/outgoing messages, and this is where you come
     in -- to map Citadel's requirements to the host operating system.

        This is how I did it for DOS:

     <Citadel's subdirectory>
               |
            VIRTUAL (ctdlvrm.sys, ctdlvnet.sys)
               |
           --------------------
            |   |  ....   |
            0   1         N
                          |
                       -------
                       |     |
                     PEON  BACKBONE

        The numeric directories correspond to the slot numbers of the
     virtual rooms, contained in ctdlvrm.sys.  Since there may be rooms
     killed from the virtual rooms, not all numeric directories will
     always be present.  The PEON and BACKBONE directories contain msgs
     from PEON and BACKBONE systems, and will be deleted by the virtadmn
     utility run in batch mode.






                                     - 28 -




        Here are the interface functions.

     --------

     void CreateVAName(char *fn, int VirtSlot, char *dir, MSG_NUMBER msg)

        This function is used to create message file names for later
     routing.  fn is a buffer to contain the created name, VirtSlot is
     the virtual room's slot number, char *dir refers to BACKBONE or PEON,
     and will be either LOCAL_DIR or LD_DIR (see ctdlvirt.h), and msg is
     the name of the file itself to be created.  It will always be a
     number.

     --------

     void makeVASysName(char *fn, char *name)

        This function is used to create the string used to open the file
     ctdlvnet.sys or ctdlvrm.sys.  Citadel-86 returns (in fn)
     "virtual\\<name>", thus keeping those two files separate from the
     rest of the system files.

     --------

     III.10 File Comments
        Some operating systems have provision for file comments (such as
     Amiga's OS), while others don't; thus, this is a system dependency.

     --------

     int StFileComSearch(void)

        This function should do whatever is necessary to begin searches
     for file comments in the current Area.  Please see FindFileComment()
     for more important notes.  This function should return TRUE if
     successful, FALSE otherwise.

     --------

     int FindFileComment(char *fileName)

        This function's task is to search for the file comment for the
     file named in fileName.  If it finds a comment, it should copy it
     into msgBuf.mbtext and return TRUE; otherwise, it should return
     FALSE.  In the interest of performance, you may make some
     assumptions: All calls to this function will be non-monotonically
     increasing (that is, "aaa" will come before "bbb" always, but there
     may be two or more calls with "aaa" as an argument in a row to this
     function before proceeding to "bbb" or terminating (calling
     EndFileComment())).  At the moment, msgBuf.mbtext is not disturbed
     between calls to this function, but this cannot be guaranteed in the
     future, even though I am currently depending on it.

     --------







                                     - 29 -




     void EndFileComment(void)

        This function terminates a series of calls for file comments in
     the current Area.

     --------

     void updFiletag(char *fileName, char *desc)

        This function should update the file tag facility with the file
     and description passed to it.  Since at least one implementation of
     Citadel can use some O.S.  capabilities for file tagging, file
     tagging is designated as a system dependency.

     -------

     III.11 Compressed Files
        Citadel-86 optionally supports commands that allow decompression
     of compressed files (like those created by ARC, ZIP, etc) during
     board operation.  The algorithms used for decompression are left up
     to the porter; Citadel-86's solution is to run an external program
     of the System Operator's choice.  Here's the interface points.  You
     may want to consider stealing the Citadel-86 source outright.

     -------

     void SendArcFiles(char protocol)

        This function's responsibility is to decompress files and send
     the contents to the user using the protocol specified in the
     parameter protocol.

     -------

     void NetDeCompress(int MTCompVal, char *fn)

        Given the file named in fn and the compress type indicated in
     MTCompVal (one of LHA_COMP, ZIP_COMP, ZOO_COMP, or ARC_COMP), this
     function should arrange to decompress the given file and make the
     results available through calls to MakeDeCompressedFilename(), see
     below.

     --------

     void MakeDeCompressedFilename(char *fn, char *Fn)

        Given a compressed file has been decompressed into its components
     (see NetDeCompress()), and the filename Fn, place in fn a string
     which can be used to open the file and read its contents or copy the
     file.  In English, prefix Fn with whatever temporary directory name
     you used.

     --------

     void KillNetDeCompress(void)






                                     - 30 -




        After having run NetDeCompress() and MakeDeCompressedFilename(),
     this function will be called to erase all traces of the decompressed
     files.  This should include all temporary directories, but not the
     original compressed file.

     --------

     char *GetCompEnglish(int CompType)

        Get a human-readable name for the specified compression type.

     --------

     char *CompExtension(int CompType)

        Get the expected "extension" or suffix of files of this type
     ("lzh", etc).

     --------

     char DeCompAvailable(int CompType)

        Does this system support decompressing files of the type CompType?

     --------

     void Compress(char CompType, char *Files, char *ArcFileName)

        This function, given the Compression type, the "mask" of files to
     compress, and the file to compress to, should perform the
     compression (presumably using an external program).

     --------

     int GetUserCompression(void)

        This function handles a request for a compression protocol.  This
     can be called either for a sysop (when selecting for Mass Transfers)
     or by a user (eventually) for .RC.

        This returns the protocol selected (LHA_COMP, etc) or NO_COMP if
     none was selected or if none are available.

     --------

     char AnyCompression(void)

        This function returns TRUE if any compression is supported,
     otherwise FALSE.

     --------

     void ReadExternalDir(char *name)








                                     - 31 -




        This function attempts to read the TOC of the given compressed
     file.  The type must be derived.

     --------

     III.12 External Protocols
     Citadel supports external protocols (protocols supplied by running
     external programs/processes/libraries/etc.) by integrating
     references to them directly into the Read and Entry command sets.

     --------

     int RunExternalProtocol(PROTOCOL *Prot, char *filelist)

        The specified protocol should be run with the given file list (a
     space separated collection of filenames).  Return TRUE on success,
     FALSE on failure.

     --------

     SystemProtocol *ReadSysProtInfo(char *string)

        This function is handed a string from ctdlprot.sys and should
     extract system- dependent information from it, place it in a
     dynamically allocated structure of type SystemProtocol, and return a
     pointer to that structure.  This structure is part of the PROTOCOL
     structure that is passed to other functions supporting external
     protocols.

        The structure of a line in CtdlProt.sys is

        [name] [flags] [selector] [system-dependent info]

        Name, flags, and selector is parsed by the main Citadel code;
     this function is responsible for extracting system dependent
     information only.

     --------

     char ExternalTransfer(PROTOCOL *Prot, char *filename)

        This function is similar to RunExternalProtocol(), but differs in
     that usually only one or more filenames are passed to
     RunExternalProtocol(), while a pathname (or analogous construct) may
     be passed to this function, and some external protocols don't deal
     well with pathnames.  This function is currently only used with the
     Net Cache (aka Fast Transfers) feature, if you want to get more idea
     of how to implement this.

     --------

     III.13 Doors

     char doDoor(char moreYet)







                                     - 32 -




        This function handles the <D> and <.D> commands.  moreYet
     indicates if a '.' was used.  This function should return either
     GOOD_SELECT (indicating all's well), BAD_SELECT (indicating a
     blunder occurred and Citadel should echo "?  etc") or BACKED_OUT,
     indicating the user decided to backspace out of their decision.
     Note doDoor() is responsible for generating the backspacing in the
     last case.

     --------

     char BackFromDoor(void)

        This function decides if Citadel, which has just come back up, is
     back from running a door or not.  This function is only called from
     initCitadel() in rooma.c, and should return TRUE only if you have
     implemented doors so that Citadel comes down before running a door.
     If you simply shell out to run a door, then this function should
     always return FALSE.

     --------

     char RunAutoDoor(int which, char ask)

        Citadel is capable of running a door when a specified user logs
     in.  This function is called in order to run the door when the user
     logs in.  which indicates which door should be run (0, 1, ..).; -1
     indicates no door should be run and FALSE should be returned.  If
     the door is run successfully then TRUE should be returned.  If ask
     is true then user-interaction is allowed, otherwise Citadel should
     immediately run the door.

     --------

     char NewUserDoor(void)

        This function is called when a user indicates they want an
     account and the system is configured to be "open".  This function
     lets the porter to implement "new user doors" for more complete
     registration.

     --------

     char LoggedInDoor(void)

        This function is called when a user logs in.  This function lets
     the porter to implement one or more doors (or hooks for doors) to be
     executed whenever any user logs in.

     --------

     void ClearDoorTimers()

        This function is called to clear the door time keepers, which are
     used to keep track of time limits on doors.







                                     - 33 -




     --------

     III.14 External Message Editors
        Citadel supports external message editors via system dependent
     code.  Actual commands to access such editors is handled in the same
     manner as external protocols, including the integration of the
     commands into the message editing command set.

     --------

     void OtherEditOptions(char **Options)

        This function is called to add external editor options to the
     entry cmd: command set.  As in external protocols, Options is an
     array of strings.  The first character of each string acts as the
     selector for that option.

     --------

     void RunRemoteEditor(int selector)

        This function is called when the user selects an external editor.
     It is entirely the responsibility of the porter to provide the
     access to the external editors.  Selector is the character typed by
     the user.

     --------

     III.15 Network Cache Support

     void VirtualCopyFileToFile(char *src, char *target)

        This function is responsible for copying the file specified by
     src to the file specified by target.  This function should be aware
     of how the system dependent functions concerning network caching and
     virtual rooms work, just in case ...  although it probably doesn't
     matter - a simply copy from source to target should suffice.

     --------

     int ChangeToCacheDir(x)

        This function should change "area" to the specified directory,
     much like getArea().

     --------

     void NetCacheName(char *buf, int slot, char *name)

        Given the slot of the system and the name of the file to access,
     construct the necessary string to allow us to open a file in the
     network caching directory and place that string in buf.

     --------







                                     - 34 -




     void MakeNetCacheName(char *buf, int slot)

        Much like NetCacheName(), this builds a string, but this only
     extends to the directory implied by the slot number.  This function
     will be used to generate strings passed to ChangeToCacheDir().

     --------

     void MakeNetCache(char *buf)

        This constructs the basic string to build the net caching
     directory, in case it hasn't been built as of yet (confg doesn't do
     it -- we can't guarantee a sysop will remember to run confg or even
     get the latest just for net caching).  This string is passed to
     mkdir().

     --------

     III.16 Biography support
        This section contains support for user biographies.

     --------

     void MoveToBioDirectory(void)

        This function puts the system in the biography area for purposes
     of running through all files named .*bio.

     --------

     IV. SysCfg.C
     --------

     void initSysSpec(void)

        Any necessary system dependent initializations for the CONFG
     process.

     --------

     int sysSpecs(char *line, int offset, char *status)

        This function should process CTDLCNFG.SYS parameters specific to
     this implementation.  line is the line to be processed.  status is a
     pointer to a char will contain TRUE if the passed line had a legal
     parameter, and FALSE if it didn't.  offset is the offset in
     cfg.codeBuf where the next value that needs to be copied into it can
     be copied, if necessary.  If something is* copied, offset should be
     changed by the copy.  In any case, the value of offset at the end of
     the function should be returned to the caller.

     --------

     char SysDepIntegrity(int *offset)







                                     - 35 -




        This function checks the system dependent parameters for any
     required consistency.  Return TRUE if all is well, otherwise FALSE.
     Optionally, you can use the illegal() call to report problems.
     Please leave legible, understandable error messages.

     --------

     int doArea(char *var, char *line, SYS_AREA *area, int offset)

        This function reads the area specified in line and places the
     result in area.  It returns the current offset into codeBuf.

     --------

     int AreaCheck(SYS_AREA *area)

        This function performs any necessary checks, such as creating
     directories, etc, for the given area.  If it runs into problems it
     should call illegal().

     --------

     char *GetDir(SYS_AREA *area)

        This function is used to extract a human readable string from a
     SYS_AREA variable for use with #event symbolic substitutions.  See
     Confg2.c for how it's used.  It should return a pointer to a static
     buffer.

     --------

     int ReadDialOut(char *line, int baud, int *offset)

        This function reads a dialout string.  It should return the
     offset into codebuf.  The dialout prefix should be stored in the
     DependentData struct of cfg.

        NB: This is a kludge, I would not do this but I haven't a choice.

     --------

     V. SysUtil.C
     ---------

     void getUtilDate(int *year, int *month, int *day, int *hours, int *
     minutes)

        Gets system date and time, and places it in the locations
     indicated above.

     ---------










                                     - 36 -




     VI. CREDITS
        I'd like to thank the the users who have participated and
     continue to participate in the Porting Citadel> room on C-86 Test
     System.  In particular: Stallion, system operator of The Phoenix
     (RIP) who has completed the first successful port of Citadel from
     the Citadel-86 implementation to another computer, namely the Amiga;
     David Parsons, who successfully ported Citadel to an Atari ST
     (STadel); John Stanley, simply for his overall computer help,
     support, and for being one of the nicest guys I've had the honor of
     knowing; and Dalnefre', since his contentiousness forced me to focus
     on what my goals were, are, and will be for this ongoing project --
     we don't agree often, but disagreement is just as valuable.  There
     have been and are others participating in Porting Citadel>, but the
     above mentioned have been the main contributors to this mess --
     blame them!

                                        -- Hue, Jr.












































                                     - 37 -




     Appendix A. Index

     #DOMAINAREA. . . . . . . . . . . . . . . . . . . . . . . . . .20.
     #event . . . . . . . . . . . . . . . . . . . . . . . . . .19, 36.
     #NETAREA . . . . . . . . . . . . . . . . . . . . . . . . . . .20.
     AbsToReadable. . . . . . . . . . . . . . . . . . . . . . . . .24.
     ANSI_PROTOTYPING. . . . . . . . . . . . . . . . . . . . . . . .3.
     AnyCompression . . . . . . . . . . . . . . . . . . . . . . . .31.
     AreaCheck. . . . . . . . . . . . . . . . . . . . . . . . . . .36.
     BackFromDoor . . . . . . . . . . . . . . . . . . . . . . . . .33.
     BeNice . . . . . . . . . . . . . . . . . . . . . . . . . . . .27.
     BufferingOff . . . . . . . . . . . . . . . . . . . . . . . . .11.
     BufferingOn. . . . . . . . . . . . . . . . . . . . . . . .10, 11.
     CallChat . . . . . . . . . . . . . . . . . . . . . . . . . . .27.
     changeBauds . . . . . . . . . . . . . . . . . . . . . . . . . .9.
     ChangeToCacheDir . . . . . . . . . . . . . . . . . . . . .34, 35.
     ChatEat. . . . . . . . . . . . . . . . . . . . . . . . . . . .26.
     ChatSend . . . . . . . . . . . . . . . . . . . . . . . . . . .26.
     chkTimeSince . . . . . . . . . . . . . . . . . . . . . . .22, 23.
     CitGetFileList . . . . . . . . . . . . . . . . . . . . . . . .18.
     ClearDoorTimers. . . . . . . . . . . . . . . . . . . . . . . .33.
     CloseSysopMenu . . . . . . . . . . . . . . . . . . . . . .14, 15.
     COMMENT_HEADER. . . . . . . . . . . . . . . . . . . . . . . . .6.
     CompExtension. . . . . . . . . . . . . . . . . . . . . . . . .31.
     Compress . . . . . . . . . . . . . . . . . . . . . . . . .30, 31.
     CopyFile . . . . . . . . . . . . . . . . . . . . . . . . . . .21.
     CopyFileGetComment . . . . . . . . . . . . . . . . . . . . . .21.
     copy_array . . . . . . . . . . . . . . . . . . . . . . . . . .24.
     copy_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . .24.
     copy_struct. . . . . . . . . . . . . . . . . . . . . . . . . .24.
     CreateVAName . . . . . . . . . . . . . . . . . . . . . . . . .29.
     ctdlcnfg.sys . . . . . . . . . . . . . . . . . . . . . . . . .35.
     ctdldir.sys. . . . . . . . . . . . . . . . . . . . . . . . . .20.
     ctdlmsg.sys . . . . . . . . . . . . . . . . . . . . . . . . . .4.
     ctdlprot.sys . . . . . . . . . . . . . . . . . . . . . . . . .32.
     ctdltabl.sys. . . . . . . . . . . . . . . . . . . . . . . . . .5.
     CurAbsolute. . . . . . . . . . . . . . . . . . . . . . . . . .24.
     DeCompAvailable. . . . . . . . . . . . . . . . . . . . . . . .31.
     DependentData . . . . . . . . . . . . . . . . . . . . . . .5, 36.
     DialExternal . . . . . . . . . . . . . . . . . . . . . . . . .25.
     DisableModem. . . . . . . . . . . . . . . . . . . . . . . . . .9.
     doArea . . . . . . . . . . . . . . . . . . . . . . . . . . . .36.
     doDoor . . . . . . . . . . . . . . . . . . . . . . . . . .32, 33.
     DoorsUsed . . . . . . . . . . . . . . . . . . . . . . . . . . .6.
     dPrintf. . . . . . . . . . . . . . . . . . . . . . . . . . . .22.
     EnableModem . . . . . . . . . . . . . . . . . . . . . . . . . .9.
     EndFileComment . . . . . . . . . . . . . . . . . . . . . .29, 30.
     ExternalTransfer . . . . . . . . . . . . . . . . . . . . . . .32.
     fastMod . . . . . . . . . . . . . . . . . . . . . . . . . . . .9.
     FileIntegrity. . . . . . . . . . . . . . . . . . . . . . . . .27.
     FindBaud. . . . . . . . . . . . . . . . . . . . . . . . . .9, 10.
     FindFileComment. . . . . . . . . . . . . . . . . . . . . . . .29.
     fl_send. . . . . . . . . . . . . . . . . . . . . . . . . .19, 28.
     getCh. . . . . . . . . . . . . . . . . . . . . . . . . . . . .11.
     GetCompEnglish . . . . . . . . . . . . . . . . . . . . . . . .31.
     GetDir . . . . . . . . . . . . . . . . . . . . . . . . . . . .36.





                                     - 38 -




     getNetBaud . . . . . . . . . . . . . . . . . . . . . . . . . .10.
     GetPrefix. . . . . . . . . . . . . . . . . . . . . . . . . . .25.
     getRawDate . . . . . . . . . . . . . . . . . . . . . . . . . .23.
     GetSysopMenuChar . . . . . . . . . . . . . . . . . . . . . . .14.
     GetUserCompression . . . . . . . . . . . . . . . . . . . . . .31.
     getUtilDate. . . . . . . . . . . . . . . . . . . . . . . . . .36.
     GiveSpaceLeft. . . . . . . . . . . . . . . . . . . . . . . . .25.
     gotCarrier. . . . . . . . . . . . . . . . . . . . . . . . .9, 10.
     HangUp. . . . . . . . . . . . . . . . . . . . . . . . . . . . .8.
     homeSpace. . . . . . . . . . . . . . . . . . . . . . . . .18, 27.
     IDLE_PAUSE . . . . . . . . . . . . . . . . . . . . . . . . . .27.
     initSysSpec. . . . . . . . . . . . . . . . . . . . . . . . . .35.
     inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .8.
     INUSE_PAUSE. . . . . . . . . . . . . . . . . . . . . . . . . .27.
     KBReady. . . . . . . . . . . . . . . . . . . . . . . . . .11, 12.
     KillDomainDirectory. . . . . . . . . . . . . . . . . . . . . .20.
     KillNetDeCompress. . . . . . . . . . . . . . . . . . . . . . .30.
     KillTempArea . . . . . . . . . . . . . . . . . . . . . . . . .27.
     LoggedInDoor . . . . . . . . . . . . . . . . . . . . . . . . .33.
     LONOTICE. . . . . . . . . . . . . . . . . . . . . . . . . . . .8.
     makeAuditName. . . . . . . . . . . . . . . . . . . . . . . . .21.
     MakeDeCompressedFilename . . . . . . . . . . . . . . . . .30, 31.
     MakeDomainDirectory. . . . . . . . . . . . . . . . . . . . . .20.
     MakeDomainFileName . . . . . . . . . . . . . . . . . . . . . .20.
     MakeNetCache . . . . . . . . . . . . . . . . . . . . . . . . .35.
     MakeNetCacheName . . . . . . . . . . . . . . . . . . . . . . .35.
     makeSysName. . . . . . . . . . . . . . . . . . . . . . . . . .20.
     makeVASysName. . . . . . . . . . . . . . . . . . . . . . . . .29.
     MenuId . . . . . . . . . . . . .7, 9, 13, 14, 15, 16, 17, 18, 19.
     MilliSecPause. . . . . . . . . . . . . . . . . . . . . . . . .24.
     MIReady . . . . . . . . . . . . . . . . . . . . . . . . . . . .8.
     ModemOpen . . . . . . . . . . . . . . . . . . . . . . . . . . .8.
     ModemShutdown . . . . . . . . . . . . . . . . . . . . . . . . .8.
     MoveFile . . . . . . . . . . . . . . . . . . . . . . . . . . .20.
     MoveToBioDirectory . . . . . . . . . . . . . . . . . . . . . .35.
     mPrintf. . . . . . . . . . . . . . . . . . . . . .15, 16, 17, 22.
     mputChar . . . . . . . . . . . . . . . . . . . . . . . . . . .12.
     mvToHomeDisk . . . . . . . . . . . . . . . . . . . . . . . . .11.
     NeedSysopInpPrompt . . . . . . . . . . . . . . . . . . . . . .17.
     NetCacheName . . . . . . . . . . . . . . . . . . . . . . .34, 35.
     NetDeCompress. . . . . . . . . . . . . . . . . . . . . . .30, 31.
     netGetAreaV2 . . . . . . . . . . . . . . . . . . . . . . . . .18.
     NetPrintf. . . . . . . . . . . . . . . . . . . . . . . . . . .22.
     netSetNewArea. . . . . . . . . . . . . . . . . . . . . . . . .18.
     NET_AREA . . . . . . . . . . . . . . . . . . . . . . . . .18, 19.
     NET_PAUSE. . . . . . . . . . . . . . . . . . . . . . . . . . .27.
     NewUserDoor. . . . . . . . . . . . . . . . . . . . . . . . . .33.
     NormalName . . . . . . . . . . . . . . . . . . . . . . . . . .28.
     OtherEditOptions . . . . . . . . . . . . . . . . . . . . . . .34.
     outMod. . . . . . . . . . . . . . . . . . . . . . . . . . . . .9.
     pause . . . . . . . . . . . . . . . . . . . . . . . . . . .8, 23.
     PROTOCOL . . . . . . . . . . . . . . . . . . . .5, 6, 30, 31, 32.
     prtNetArea . . . . . . . . . . . . . . . . . . . . . . . . . .18.
     ReadBps. . . . . . . . . . . . . . . . . . . . . . . . . . . .26.
     ReadDate . . . . . . . . . . . . . . . . . . . . . . .18, 23, 24.
     ReadDialOut. . . . . . . . . . . . . . . . . . . . . . . .26, 36.





                                     - 39 -




     ReadExternalDir. . . . . . . . . . . . . . . . . . . . . . . .31.
     ReadSysProtInfo. . . . . . . . . . . . . . . . . . . . . . . .32.
     receive. . . . . . . . . . . . . . . . . . . . . . . . . . . .25.
     RedirectName . . . . . . . . . . . . . . . . . . . . . . . . .19.
     RegisterSysopMenu . . . . . . . . . . . . . . . . . . .9, 13, 14.
     Reinitialize. . . . . . . . . . . . . . . . . . . . . . . .8, 10.
     ReInitModem. . . . . . . . . . . . . . . . . . . . . . . . . .10.
     ResultVal. . . . . . . . . . . . . . . . . . . . . . . . . . .28.
     RottenDial . . . . . . . . . . . . . . . . . . . . . . . . . .11.
     RunAutoDoor. . . . . . . . . . . . . . . . . . . . . . . . . .33.
     RunExternalProtocol. . . . . . . . . . . . . . . . . . . . . .32.
     RunRemoteEditor. . . . . . . . . . . . . . . . . . . . . . . .34.
     safeopen . . . . . . . . . . . . . . . . . . . . . . . . .19, 21.
     ScreenUser . . . . . . . . . . . . . . . . . . . . . . . . . .12.
     ScrNewUser . . . . . . . . . . . . . . . . . . . . . . . . . .12.
     ScrTimeUpdate. . . . . . . . . . . . . . . . . . . . . . . . .12.
     SECTOR_ID . . . . . . . . . . . . . . . . . . . . . . . . . . .4.
     SendArcFiles . . . . . . . . . . . . . . . . . . . . . . . . .30.
     setNetCallBaud . . . . . . . . . . . . . . . . . . . . . . . .10.
     setRawDate . . . . . . . . . . . . . . . . . . . . . . . . . .23.
     SetSpace . . . . . . . . . . . . . . . . . . . . . . . . . . .19.
     simpleGetch. . . . . . . . . . . . . . . . . . . . . . . . . .12.
     SpecialMessage . . . . . . . . . . . . . . . . . . . . . . . .12.
     splitF . . . . . . . . . . . . . . . . . . . . . . . . . . . .22.
     startTimer . . . . . . . . . . . . . . . . . . . . . . . .22, 23.
     StFileComSearch. . . . . . . . . . . . . . . . . . . . . . . .29.
     SysArea. . . . . . . . . . . . . . . . . . . . . . . . . . . .20.
     SysDepIntegrity. . . . . . . . . . . . . . . . . . . . . . . .35.
     sysGetSendFilesV2. . . . . . . . . . . . . . . . . . . . . . .19.
     SysopCloseContinual. . . . . . . . . . . . . . . . . . . . . .17.
     SysopContinual . . . . . . . . . . . . . . . . . . . . . .16, 17.
     SysopContinualString . . . . . . . . . . . . . . . . . . . . .17.
     SysopDisplayInfo . . . . . . . . . . . . . . . . . . . . . . .16.
     SysopError . . . . . . . . . . . . . . . . . . . . . . . . . .15.
     SysopGetNumber . . . . . . . . . . . . . . . . . . . . . . . .16.
     SysopGetYesNo. . . . . . . . . . . . . . . . . . . . . . . . .15.
     SysopInfoReport. . . . . . . . . . . . . . . . . . . . . . . .16.
     SysopMenuPrompt. . . . . . . . . . . . . . . . . . . . . . . .15.
     SysopPrintf. . . . . . . . . . . . . . . . . . . . . . . . . .17.
     SysopRequestString . . . . . . . . . . . . . . . . . . . . . .15.
     sysRoomLeft. . . . . . . . . . . . . . . . . . . . . . . . . .19.
     sysSendFiles . . . . . . . . . . . . . . . . . . . . . . . . .19.
     sysSpecs . . . . . . . . . . . . . . . . . . . . . . . . . . .35.
     systemCommands . . . . . . . . . . . . . . . . . . . . . . . .25.
     systemInit. . . . . . . . . . . . . . . . . . . . . . . . .5, 25.
     SystemProtocol . . . . . . . . . . . . . . . . . . . . . . . .32.
     systemShutdown . . . . . . . . . . . . . . . . . . . . . . . .25.
     SYSTEM_CLOCK . . . . . . . . . . . . . . . . . . . . . . . . .13.
     SYS_AREA. . . . . . . . . . . . . . . . . . . . . . . .2, 20, 36.
     totalBytes . . . . . . . . . . . . . . . . . . . . . . . . . .21.
     ToTempArea . . . . . . . . . . . . . . . . . . . . . . . . . .27.
     UNS_16 . . . . . . . . . . . . . . . . . . . . . . . . . . . .20.
     updFiletag . . . . . . . . . . . . . . . . . . . . . . . . . .30.
     ValidArea. . . . . . . . . . . . . . . . . . . . . . . . . . .19.
     ValidDirFileName . . . . . . . . . . . . . . . . . . . . . . .27.
     VirtualCopyFileToFile. . . . . . . . . . . . . . . . . . . . .34.





                                     - 40 -




     WhatDay. . . . . . . . . . . . . . . . . . . . . . . . . . . .26.
     zero_array . . . . . . . . . . . . . . . . . . . . . . . . . .26.
     zero_struct. . . . . . . . . . . . . . . . . . . . . . . . . .26.


























































                                     - 41 -




